<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>銀河霓虹射擊 EX</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #050510;
            overflow: hidden; /* 防止捲動 */
            touch-action: none; /* 禁止手機預設觸控行為 */
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
        }

        canvas {
            display: block;
            cursor: none; /* 隱藏滑鼠 */
        }

        /* 霓虹文字特效 */
        .neon-text-cyan {
            text-shadow: 0 0 5px #fff, 0 0 10px #0ff, 0 0 20px #0ff;
        }
        .neon-text-magenta {
            text-shadow: 0 0 5px #fff, 0 0 10px #f0f, 0 0 20px #f0f;
        }
        
        /* UI 動畫 */
        @keyframes pulse-border {
            0% { border-color: rgba(0, 255, 255, 0.4); box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }
            50% { border-color: rgba(0, 255, 255, 1); box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
            100% { border-color: rgba(0, 255, 255, 0.4); box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }
        }

        .hud-panel {
            background: linear-gradient(90deg, rgba(0,0,0,0.8) 0%, rgba(10,20,40,0.6) 50%, rgba(0,0,0,0.8) 100%);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(4px);
        }

        .btn-start {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn-start:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
            transform: scale(1.05);
        }
    </style>
</head>
<body class="w-screen h-screen flex items-center justify-center bg-gray-900">

    <!-- 遊戲外框 -->
    <div id="game-container" class="relative w-full h-full md:w-[800px] md:h-[600px] md:rounded-xl md:border md:border-slate-700 overflow-hidden bg-black">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD 資訊列 -->
        <div id="hud" class="absolute top-0 left-0 w-full p-4 flex justify-between items-start hud-panel z-10 pointer-events-none">
            <div class="flex flex-col">
                <span class="text-xs text-cyan-300 opacity-70">SCORE</span>
                <span id="score" class="text-3xl font-bold text-white neon-text-cyan">0</span>
            </div>
            
            <!-- 能量條/狀態 -->
            <div class="flex flex-col items-center">
                 <div id="combo-display" class="hidden text-yellow-400 font-bold text-xl italic animate-bounce">COMBO x<span id="combo-count">0</span></div>
            </div>

            <div class="flex flex-col items-end">
                <span class="text-xs text-pink-300 opacity-70">SHIELD</span>
                <div id="lives-container" class="flex gap-1 text-2xl text-pink-500 neon-text-magenta">
                    ❤️❤️❤️
                </div>
            </div>
        </div>

        <!-- 開始/暫停/結束 畫面 -->
        <div id="modal-screen" class="absolute inset-0 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center z-50 transition-opacity duration-300">
            <h1 class="text-5xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-cyan-400 neon-text-cyan mb-2 italic transform -skew-x-6">
                NEON GALAXY
            </h1>
            <p class="text-cyan-200 mb-8 tracking-widest text-sm">DEFEND THE SYSTEM</p>
            
            <div id="final-score-container" class="hidden flex-col items-center mb-8">
                <p class="text-gray-400 text-sm">MISSION FAILED</p>
                <p class="text-4xl text-white font-bold" id="final-score">0</p>
            </div>

            <div class="space-y-4 flex flex-col items-center">
                <button id="start-button" class="btn-start px-12 py-4 text-xl font-bold rounded">
                    START GAME
                </button>
                <div class="text-gray-500 text-xs mt-4 space-y-1 text-center">
                    <p>滑鼠 / 觸控 拖曳移動</p>
                    <p>或使用 WASD / 方向鍵 控制</p>
                </div>
            </div>
        </div>
        
        <!-- 暫停提示 -->
        <div id="pause-indicator" class="hidden absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-[2px] z-40 pointer-events-none">
            <h2 class="text-4xl text-white font-bold tracking-widest neon-text-cyan">PAUSED</h2>
        </div>
    </div>

<script>
    /**
     * 遊戲核心邏輯
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI 元素
    const scoreEl = document.getElementById('score');
    const livesContainer = document.getElementById('lives-container');
    const modalScreen = document.getElementById('modal-screen');
    const startButton = document.getElementById('start-button');
    const finalScoreContainer = document.getElementById('final-score-container');
    const finalScoreEl = document.getElementById('final-score');
    const comboDisplay = document.getElementById('combo-display');
    const comboCountEl = document.getElementById('combo-count');
    const pauseIndicator = document.getElementById('pause-indicator');

    // 遊戲狀態變數
    let gameActive = false;
    let isPaused = false;
    let score = 0;
    let lives = 3;
    let frames = 0;
    let combo = 0;
    let comboTimer = 0;
    
    // 實體陣列
    let player;
    let bullets = [];
    let enemies = [];
    let particles = [];
    let floatingTexts = [];
    let stars = [];
    let powerUps = [];

    // 音效 (Tone.js)
    let synth, metalSynth, noiseSynth;
    let audioInitialized = false;

    // 畫面震動變數
    let shakeIntensity = 0;

    // 輸入狀態
    const keys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        w: false, s: false, a: false, d: false,
        W: false, S: false, A: false, D: false
    };

    // --- 音效系統 ---
    async function initAudio() {
        if (audioInitialized) return;
        await Tone.start();
        
        // 射擊音效
        synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 },
            volume: -10
        }).toDestination();

        // 爆炸音效
        metalSynth = new Tone.MetalSynth({
            frequency: 200, envelope: { attack: 0.001, decay: 0.2, release: 0.2 },
            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5,
            volume: -8
        }).toDestination();

        // 升級音效
        noiseSynth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 },
            volume: -5
        }).toDestination();

        audioInitialized = true;
    }

    // --- 輔助函式 ---
    function randomRange(min, max) { return Math.random() * (max - min) + min; }
    function randomColor() { return `hsl(${Math.random() * 360}, 70%, 60%)`; }
    
    // 畫面震動設定
    function screenShake(intensity) {
        shakeIntensity = intensity;
    }

    // --- 類別定義 ---

    // 漂浮文字 (分數顯示)
    class FloatingText {
        constructor(x, y, text, color, size = 20) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.size = size;
            this.life = 1.0; // 不透明度
            this.velocity = { x: randomRange(-1, 1), y: -2 };
        }
        update() {
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.life -= 0.02;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = `bold ${this.size}px Orbitron`;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    // 背景星星 (視差滾動)
    class Star {
        constructor() {
            this.reset(true);
        }
        reset(randomY = false) {
            this.x = Math.random() * canvas.width;
            this.y = randomY ? Math.random() * canvas.height : -10;
            this.z = Math.random() * 3 + 0.5; // 深度，決定速度和大小
            this.size = this.z * 0.8;
            this.speed = this.z * 0.5;
            this.opacity = Math.random() * 0.5 + 0.3;
        }
        update() {
            // 速度隨玩家連擊或難度增加 (視覺衝刺感)
            let speedMod = 1 + (score / 5000); 
            this.y += this.speed * speedMod;
            if (this.y > canvas.height) this.reset();
        }
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // 粒子系統
    class Particle {
        constructor(x, y, color, speed, size) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * speed;
            this.vx = Math.cos(angle) * velocity;
            this.vy = Math.sin(angle) * velocity;
            this.size = size;
            this.friction = 0.95;
            this.alpha = 1;
            this.decay = randomRange(0.015, 0.03);
        }
        update() {
            this.vx *= this.friction;
            this.vy *= this.friction;
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.decay;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // 玩家飛船
    class Player {
        constructor() {
            this.width = 40;
            this.height = 50;
            this.x = canvas.width / 2 - this.width / 2;
            this.y = canvas.height - 100;
            this.speed = 8; // 鍵盤移動速度
            this.color = '#00ffff';
            this.bullets = [];
            this.cooldown = 0;
            this.shielded = false;
            this.powerUpType = null; // 'rapid', 'scatter'
            this.powerUpTimer = 0;
        }

        update() {
            // 鍵盤移動邏輯
            if (keys.ArrowUp || keys.w || keys.W) this.y -= this.speed;
            if (keys.ArrowDown || keys.s || keys.S) this.y += this.speed;
            if (keys.ArrowLeft || keys.a || keys.A) this.x -= this.speed;
            if (keys.ArrowRight || keys.d || keys.D) this.x += this.speed;

            // 邊界限制
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
            if (this.y < 0) this.y = 0;
            if (this.y + this.height > canvas.height) this.y = canvas.height - this.height;

            // 處理冷卻與PowerUp
            if (this.cooldown > 0) this.cooldown--;
            if (this.powerUpTimer > 0) {
                this.powerUpTimer--;
                if (this.powerUpTimer <= 0) this.powerUpType = null;
            }

            // 自動射擊
            this.shoot();
            
            // 產生尾焰粒子
            if (frames % 2 === 0) {
                particles.push(new Particle(
                    this.x + this.width/2, 
                    this.y + this.height, 
                    '#0ff', 2, 2
                ));
            }
        }

        draw() {
            ctx.save();
            // 發光特效
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.color;
            
            // 護盾特效
            if (this.shielded) {
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 50, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.abs(Math.sin(frames * 0.1))})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // 飛船本體 (三角形)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(this.x + this.width / 2, this.y);
            ctx.lineTo(this.x, this.y + this.height);
            ctx.lineTo(this.x + this.width / 2, this.y + this.height - 10);
            ctx.lineTo(this.x + this.width, this.y + this.height);
            ctx.closePath();
            ctx.fill();
            
            // 核心
            ctx.fillStyle = this.powerUpType ? '#ff00ff' : '#00ffff';
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y + this.height/2 + 5, 5, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        shoot() {
            let fireRate = this.powerUpType === 'rapid' ? 4 : 10;
            
            if (this.cooldown <= 0) {
                if (this.powerUpType === 'scatter') {
                    // 散射
                    bullets.push(new Bullet(this.x + this.width / 2, this.y, 0, -10));
                    bullets.push(new Bullet(this.x + this.width / 2, this.y, -2, -9));
                    bullets.push(new Bullet(this.x + this.width / 2, this.y, 2, -9));
                } else {
                    // 普通射擊
                    bullets.push(new Bullet(this.x + this.width / 2, this.y, 0, -12));
                }
                
                this.cooldown = fireRate;
                
                // 音效
                if (audioInitialized) {
                    synth.triggerAttackRelease(this.powerUpType ? "C6" : "C5", "32n");
                }
            }
        }
    }

    // 子彈
    class Bullet {
        constructor(x, y, vx, vy) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.width = 4;
            this.height = 12;
            this.color = '#ff0';
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
            ctx.restore();
        }
    }

    // 敵人
    class Enemy {
        constructor() {
            this.radius = randomRange(15, 25);
            this.x = randomRange(this.radius, canvas.width - this.radius);
            this.y = -this.radius;
            // 分數越高敵人越快
            let speedMultiplier = 1 + (score / 10000); 
            this.vy = randomRange(1, 3) * speedMultiplier;
            this.vx = randomRange(-0.5, 0.5); 
            this.color = `hsl(${randomRange(280, 340)}, 80%, 60%)`; // 紫/粉色系
            this.hp = Math.floor(this.radius / 8) + Math.floor(score/2000);
            this.type = Math.random() > 0.8 ? 'spinner' : 'normal';
            this.angle = 0;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            if(this.type === 'spinner') this.angle += 0.1;
            
            // 邊界反彈 (X軸)
            if(this.x < this.radius || this.x > canvas.width - this.radius) this.vx *= -1;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            if(this.type === 'spinner') ctx.rotate(this.angle);
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            ctx.fillStyle = '#000'; // 內部黑色
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;

            // 繪製六邊形或圓形
            ctx.beginPath();
            if (this.type === 'spinner') {
                const sides = 4;
                for (let i = 0; i < sides; i++) {
                    ctx.lineTo(this.radius * Math.cos(i * 2 * Math.PI / sides), this.radius * Math.sin(i * 2 * Math.PI / sides));
                }
            } else {
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();

            // 顯示血量 (如果 > 1)
            /*
            if(this.hp > 1) {
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.hp, 0, 0);
            }
            */
            ctx.restore();
        }
    }

    // 道具
    class PowerUp {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.type = Math.random() > 0.5 ? 'shield' : (Math.random() > 0.5 ? 'rapid' : 'scatter');
            this.radius = 15;
            this.vy = 2;
            this.color = this.type === 'shield' ? '#0f0' : '#ff0';
            this.text = this.type === 'shield' ? 'S' : (this.type === 'rapid' ? 'R' : 'W');
        }
        update() {
            this.y += this.vy;
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    // --- 遊戲循環 ---

    function initGame() {
        resizeCanvas();
        score = 0;
        lives = 3;
        frames = 0;
        combo = 0;
        gameActive = true;
        isPaused = false;
        
        // 重置物件
        player = new Player();
        bullets = [];
        enemies = [];
        particles = [];
        floatingTexts = [];
        powerUps = [];
        
        // 初始化星星
        stars = [];
        for(let i=0; i<80; i++) stars.push(new Star());

        // UI重置
        scoreEl.innerText = "0";
        updateLivesUI();
        modalScreen.style.opacity = '0';
        setTimeout(() => {
            modalScreen.style.display = 'none';
        }, 300);
        
        animate();
    }

    function spawnEnemies() {
        // 難度控制：基礎生成率 + 分數影響
        let spawnRate = 60;
        if(score > 1000) spawnRate = 50;
        if(score > 5000) spawnRate = 35;
        if(score > 10000) spawnRate = 20;

        if (frames % spawnRate === 0) {
            enemies.push(new Enemy());
        }
    }

    function createExplosion(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color, 4, randomRange(1, 4)));
        }
    }

    function updateLivesUI() {
        let hearts = '';
        for(let i=0; i<lives; i++) hearts += '❤️';
        livesContainer.innerHTML = hearts;
        if(lives <= 1) livesContainer.classList.add('animate-pulse');
        else livesContainer.classList.remove('animate-pulse');
    }

    function gameOver() {
        gameActive = false;
        if(audioInitialized) {
             metalSynth.triggerAttackRelease(100, 1);
        }
        
        finalScoreEl.innerText = score;
        finalScoreContainer.style.display = 'flex';
        startButton.innerText = "TRY AGAIN";
        
        modalScreen.style.display = 'flex';
        setTimeout(() => modalScreen.style.opacity = '1', 50);
    }

    function animate() {
        if (!gameActive) return;
        
        requestAnimationFrame(animate);

        if(isPaused) return;

        frames++;

        // 1. 清除畫布
        ctx.fillStyle = '#050510'; // 深色背景
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. 畫面震動套用
        if (shakeIntensity > 0) {
            ctx.save();
            const dx = Math.random() * shakeIntensity - shakeIntensity / 2;
            const dy = Math.random() * shakeIntensity - shakeIntensity / 2;
            ctx.translate(dx, dy);
            shakeIntensity *= 0.9; // 震動衰減
            if(shakeIntensity < 0.5) shakeIntensity = 0;
        }

        // 3. 繪製背景星星
        stars.forEach(star => {
            star.update();
            star.draw();
        });

        // 4. 玩家邏輯
        player.update();
        player.draw();

        // 5. 子彈邏輯
        bullets.forEach((b, index) => {
            b.update();
            b.draw();
            // 移除出界子彈
            if (b.y < -50) bullets.splice(index, 1);
        });

        // 6. 敵人邏輯 & 碰撞檢測
        enemies.forEach((enemy, eIndex) => {
            enemy.update();
            enemy.draw();

            // 子彈擊中敵人
            bullets.forEach((bullet, bIndex) => {
                const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
                if (dist < enemy.radius + bullet.width) {
                    enemy.hp--;
                    createExplosion(bullet.x, bullet.y, '#ff0', 3); // 小火花
                    bullets.splice(bIndex, 1); // 移除子彈

                    if (enemy.hp <= 0) {
                        // 敵人死亡
                        createExplosion(enemy.x, enemy.y, enemy.color, 15); // 大爆炸
                        enemies.splice(eIndex, 1);
                        screenShake(5); // 震動
                        
                        // 分數計算
                        let pts = 100;
                        if(combo > 1) pts += combo * 10;
                        score += pts;
                        scoreEl.innerText = score;

                        // 連擊系統
                        combo++;
                        comboTimer = 120; // 2秒維持連擊
                        updateComboUI();

                        // 漂浮文字
                        floatingTexts.push(new FloatingText(enemy.x, enemy.y, `+${pts}`, '#fff'));

                        // 掉落道具機率 (5%)
                        if (Math.random() < 0.05) {
                            powerUps.push(new PowerUp(enemy.x, enemy.y));
                        }
                        
                        // 音效
                        if(audioInitialized) metalSynth.triggerAttackRelease("16n");
                    }
                }
            });

            // 敵人撞到玩家
            const distPlayer = Math.hypot(player.x + player.width/2 - enemy.x, player.y + player.height/2 - enemy.y);
            if (distPlayer < enemy.radius + player.width/2 - 5) {
                enemies.splice(eIndex, 1);
                createExplosion(enemy.x, enemy.y, '#f00', 20);
                screenShake(15);
                
                if (player.shielded) {
                    player.shielded = false;
                    audioInitialized && metalSynth.triggerAttackRelease(100, 0.5);
                } else {
                    lives--;
                    updateLivesUI();
                    audioInitialized && metalSynth.triggerAttackRelease(50, 1);
                    if (lives <= 0) gameOver();
                }
            }

            // 移除出界敵人
            if (enemy.y > canvas.height + 50) enemies.splice(eIndex, 1);
        });

        // 7. 道具邏輯
        powerUps.forEach((p, index) => {
            p.update();
            p.draw();
            
            // 吃到道具
            const dist = Math.hypot(player.x + player.width/2 - p.x, player.y + player.height/2 - p.y);
            if (dist < p.radius + player.width/2) {
                if (p.type === 'shield') {
                    player.shielded = true;
                    floatingTexts.push(new FloatingText(player.x, player.y, "SHIELD!", '#0f0', 30));
                } else {
                    player.powerUpType = p.type;
                    player.powerUpTimer = 600; // 10秒
                    floatingTexts.push(new FloatingText(player.x, player.y, "WEAPON UP!", '#ff0', 30));
                }
                
                if(audioInitialized) noiseSynth.triggerAttackRelease("C5", "8n");
                powerUps.splice(index, 1);
            }
            if (p.y > canvas.height + 50) powerUps.splice(index, 1);
        });

        // 8. 粒子邏輯
        particles.forEach((p, index) => {
            p.update();
            p.draw();
            if (p.alpha <= 0) particles.splice(index, 1);
        });

        // 9. 漂浮文字
        floatingTexts.forEach((ft, index) => {
            ft.update();
            ft.draw();
            if (ft.life <= 0) floatingTexts.splice(index, 1);
        });

        // 生成敵人
        spawnEnemies();

        // 連擊計時器
        if(combo > 0) {
            comboTimer--;
            if(comboTimer <= 0) {
                combo = 0;
                updateComboUI();
            }
        }

        // 震動 restore
        if (shakeIntensity > 0 || ctx.shakeActive) {
            ctx.restore();
        }
    }

    function updateComboUI() {
        if(combo > 1) {
            comboDisplay.classList.remove('hidden');
            comboCountEl.innerText = combo;
        } else {
            comboDisplay.classList.add('hidden');
        }
    }

    // --- 事件監聽 ---

    // 調整 Canvas 大小
    function resizeCanvas() {
        // 獲取容器大小
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        // 確保玩家不卡在牆外 (如果正在遊戲中)
        if(player) {
            if (player.x > canvas.width) player.x = canvas.width - player.width;
            if (player.y > canvas.height) player.y = canvas.height - player.height;
        }
    }
    
    window.addEventListener('resize', resizeCanvas);

    // 滑鼠/觸控 移動 (相對座標修正)
    function handleInputMove(clientX, clientY) {
        if (!gameActive || isPaused) return;
        const rect = canvas.getBoundingClientRect();
        // 中心對齊手指/鼠標
        let tx = clientX - rect.left - player.width / 2;
        let ty = clientY - rect.top - player.height / 2;
        
        // 簡單的平滑處理 (Lerp)
        player.x += (tx - player.x) * 0.2;
        player.y += (ty - player.y) * 0.2;
    }

    canvas.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); // 重要：防止捲動
        handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    // 鍵盤控制
    window.addEventListener('keydown', e => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
        if (e.key === 'Escape' && gameActive) togglePause();
    });
    window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
    });

    // 暫停功能
    function togglePause() {
        isPaused = !isPaused;
        if(isPaused) {
            pauseIndicator.classList.remove('hidden');
        } else {
            pauseIndicator.classList.add('hidden');
            animate();
        }
    }

    // 開始按鈕
    startButton.addEventListener('click', async () => {
        await initAudio(); // 瀏覽器政策需要使用者互動才能播音
        initGame();
    });

    // 初始化一次 Canvas 大小
    resizeCanvas();

</script>
</body>
</html>